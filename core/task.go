package core

import (
	"encoding/json"
	"path"
	"strconv"

	"github.com/supergiant/supergiant/common"
)

type TaskCollection struct {
	core *Core
}

type TaskResource struct {
	collection *TaskCollection
	*common.Task
}

// NOTE this does not inherit from common like model does; all we need is a List
// object, internally, that has a slice of our composed model above.
type TaskList struct {
	Items []*TaskResource `json:"items"`
}

const (
	statusQueued  = "QUEUED"
	statusRunning = "RUNNING"
	statusFailed  = "FAILED"
)

// etcdKey implements the Collection interface.
func (c *TaskCollection) etcdKey(id common.ID) string {
	key := "/tasks"
	if id != nil {
		key = path.Join(key, common.StringID(id))
	}
	return key
}

// initializeResource implements the Collection interface.
func (c *TaskCollection) initializeResource(r Resource) error {
	resource := r.(*TaskResource)
	resource.collection = c
	return nil
}

// List returns an TaskList.
func (c *TaskCollection) List() (*TaskList, error) {
	list := new(TaskList)
	err := c.core.db.listInOrder(c, list)
	return list, err
}

// New initializes an Task with a pointer to the Collection.
func (c *TaskCollection) New() *TaskResource {
	return &TaskResource{
		Task: &common.Task{
			Meta: common.NewMeta(),
		},
	}
}

// Create takes an Task and creates it in etcd. It also creates a Kubernetes
// Namespace with the name of the Task.
func (c *TaskCollection) Create(r *TaskResource) (*TaskResource, error) {
	if err := c.core.db.createInOrder(c, r); err != nil {
		return nil, err
	}
	return r, nil
}

// Get takes a name and returns an TaskResource if it exists.
func (c *TaskCollection) Get(id common.ID) (*TaskResource, error) {
	r := c.New()
	if err := c.core.db.get(c, id, r); err != nil {
		return nil, err
	}

	// NOTE have to set ID since it is autogenerated, and the Get() method does
	// not handle parsing keys like the other _InOrder methods do
	r.ID = id

	return r, nil
}

// NOTE kinda like a New().Save()
func (c *TaskCollection) Start(t common.TaskType, msg interface{}) (*TaskResource, error) {
	data, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}

	task := c.New()
	task.Type = t
	task.Data = data
	task.Status = statusQueued
	task.MaxAttempts = 20

	return c.Create(task)
}

// Resource-level
//==============================================================================

// Delete deletes the Task in etcd.
func (r *TaskResource) Delete() error {
	return r.collection.core.db.delete(r.collection, r.ID)
}

// Save saves the Task in etcd through an update.
func (r *TaskResource) Save() error {
	return r.collection.core.db.update(r.collection, r.ID, r)
}

// Implements OrderedModel interface
func (r *TaskResource) setID(id common.ID) {
	r.ID = id
}

func (r *TaskResource) IsQueued() bool {
	return r.Status == statusQueued
}

// Claim updates the Task status to "RUNNING" and returns nil. compareAndSwap is
// used to prevent a race condition and ensure only one worker performs the task.
func (r *TaskResource) Claim() error {
	// NOTE we de-ref the task because the DB will strip the ID (maybe a TODO)
	prev := *r

	// NOTE we have to do this instead of the above, because nested pointers are
	// not de-referenced.
	t := *r.Task
	t.Status = statusRunning
	next := &TaskResource{Task: &t}

	return r.collection.core.db.compareAndSwap(r.collection, r.ID, &prev, next)
}

func (r *TaskResource) RecordError(err error) error {
	Log.Error(err)

	r.Error = err.Error()
	if r.Attempts < r.MaxAttempts {
		r.Status = statusQueued // Add back to queue for retry
	} else {
		r.Status = statusFailed // TODO failed tasks will build up in the queue
	}
	r.Attempts++

	return r.Save()
}

func (r *TaskResource) TypeName() string {
	switch r.Type {
	case common.TaskTypeDeleteApp:
		return "DeleteApp"
	case common.TaskTypeDeleteComponent:
		return "DeleteComponent"
	case common.TaskTypeDeployComponent:
		return "DeployComponent"
	case common.TaskTypeStartInstance:
		return "StartInstance"
	case common.TaskTypeStopInstance:
		return "StopInstance"
	default:
		return strconv.Itoa(int(r.Type))
	}
}
